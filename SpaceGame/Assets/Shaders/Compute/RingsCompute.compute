#pragma kernel CalcRings
#pragma kernel ClearFrame

//NOTE: THIS ONLY WORKS FOR 1 PLANET (YET)    

static const float PI = 3.14159265f;
static const float gravConstant = 0.01f;
static const float particleMass = 1;

RWTexture2D<float4> particlesTexture;
RWTexture2D<float4> camDepthTexture;

float4x4 projectionMatrix;
float2 camSize;

struct Particle
{
    float3 position;
    float3 velocity;
    float3 color;
};

struct Ring
{
    float4 color;
    int density;
    int width;
};

RWStructuredBuffer<Particle> particles;
RWStructuredBuffer<Ring> rings;

float particleCount;
int ringCount;
float startRingDistance;

float timeStep;
float time;

float planetMass;
float planetRadius;
float3 planetPos;

bool firstLoop;

float ringWidthOffset;

float3 RandomVector()
{
    float random1 = frac(sin(dot(time, float2(12.9898, 78.233))) * 43758.5453);
    float random2 = frac(sin(dot(time, float2(94.9013, 72.623))) * 63456.1789);
    float random3 = frac(sin(dot(time, float2(78.233, 45.5019))) * 87651.3342);
    return float3(random1, random2, random3);
}

float RandomFloat()
{
    return frac(sin(dot(time * 2, float2(12.9898, 78.233))) * 43758.5453);
}

int GetRingIndex(int particleID)
{
    int index;
    int particlesCheck;
    for (int i = 0; i < ringCount; i++)
    {
        particlesCheck += rings[i].density;
        if (particleID <= particlesCheck)
        {
            index = i;
            break;
        }
    }
    return index;
}

int RingRelativeID(int ringID, int particleID)
{
    int relativeID = particleID;
    
    for (int i = 0; i < ringID; i++)
    {
        relativeID -= rings[i].density;
    }
    return relativeID;
}

float CalcRingDistance(int ringID, int particleID)
{
    float distance = 0;
    distance += planetRadius + startRingDistance;
    
    float ringWidthRow = floor(RingRelativeID(ringID, particleID) / (rings[ringID].density / (rings[ringID].width)));;
    float widthOffset = ringWidthRow * ringWidthOffset;
    distance += widthOffset;
    
    float offset = 0;
    for (int i = 0; i < ringID; i++)
    {
        offset += (rings[i].width + 5) * ringWidthOffset;
    }
    distance += offset;
    
    return distance;
}

float2 World3DToScreen2D(float3 worldPos3D)
{
    float4 posClip = mul(projectionMatrix, float4(worldPos3D, 1)).xyzw;
    posClip /= posClip.w;
    float2 halfCam = camSize * 0.5f;
    return float2((posClip.x * halfCam.x) + halfCam.x, (posClip.y * halfCam.y) + halfCam.y);
}

[numthreads(256, 1, 1)]
void CalcRings(uint3 id : SV_DispatchThreadID)
{
    if (id.x < 0 || id.x >= particleCount)
        return;
    
    int currentID = id.x;
    Particle p = particles[currentID];
      
    if (firstLoop)
    {
        int ringIndex = GetRingIndex(currentID);
              
        ringWidthOffset = 0.1f;
        float distance = CalcRingDistance(ringIndex, currentID);
        
        float heightOffset = planetPos.y;
        
        float angle = 360.0 / (rings[ringIndex].density / rings[ringIndex].width) * RingRelativeID(ringIndex, currentID);
        angle = angle * (PI / 180);
        
        p.position = float3(cos(angle) * distance + planetPos.x, heightOffset, sin(angle) * distance + planetPos.z);
                                      
        //calculate initial velocity for perfect orbit based on distance
        float3 forceDirection = planetPos - p.position;
        float forceDirectionLength = length(forceDirection);
        float3 unitPerpVector = normalize(float3(forceDirection.z, forceDirection.y, -forceDirection.x));
        float centForce = (gravConstant * planetMass) / sqrt(forceDirectionLength);
                 
        p.velocity = (unitPerpVector * centForce);
        p.color = rings[ringIndex].color;
    }
     
    //calculate newton
    float3 forceDirection = planetPos - p.position;
    float forceDirectionLength = length(forceDirection);
    float gravityForce = gravConstant * (planetMass * particleMass) / (forceDirectionLength * forceDirectionLength);
    float3 forceVector = normalize(forceDirection) * gravityForce;
   
    //set velocity and position using newton
    p.velocity += forceVector;
    p.position += p.velocity * timeStep;
          
    float2 particleScreenPos = World3DToScreen2D(p.position);
      
    particles[currentID] = p;
    
    //TODO dont render if behind object
    
    //if (camDepthTexture[particleScreenPos].r < 10)
    //{
    //    return;
    //}
           
    //render
    particlesTexture[particleScreenPos] = float4(p.color, 1);
}

[numthreads(8, 8, 1)]
void ClearFrame(uint3 id : SV_DispatchThreadID)
{
    //clear texture
    particlesTexture[id.xy] = float4(0, 0, 0, 0);
}