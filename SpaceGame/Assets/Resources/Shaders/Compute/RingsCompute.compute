#pragma kernel CalcRings
#pragma kernel ClearFrame

#include "UnityCG.cginc"

static const float PI = 3.14159265f;
static const float particleMass = 1;

float gravConstant = 0.01f;

RWTexture2D<float4> particlesTexture;
Texture2D<float4> camDepthTexture;

float4x4 projectionMatrix;
float2 camSize;

float camNearClipPlane;
float camFarClipPlane;

struct Planet
{
    float3 position;
    float mass;
};  
struct Particle
{
    float3 position;
    float3 velocity;
    float3 color;
};
struct Ring
{
    float4 color;
    int density;
    int width;
};

RWStructuredBuffer<Particle> particles;
RWStructuredBuffer<Ring> rings;
RWStructuredBuffer<Planet> planets;

float particleCount;
int ringCount;
int planetCount;
float startRingDistance;

float timeStep;
float time;

int parentPlanetID;
float parentPlanetRadius;
    
bool firstLoop;

float ringWidthOffset;

float3 RandomVector()
{
    float random1 = frac(sin(dot(time, float2(12.9898, 78.233))) * 43758.5453);
    float random2 = frac(sin(dot(time, float2(94.9013, 72.623))) * 63456.1789);
    float random3 = frac(sin(dot(time, float2(78.233, 45.5019))) * 87651.3342);
    return float3(random1, random2, random3);
}

float RandomFloat()
{
    return frac(sin(dot(time * 2, float2(12.9898, 78.233))) * 43758.5453);
}

int GetRingIndex(int particleID)
{
    int index;
    int particlesCheck;
    for (int i = 0; i < ringCount; i++)
    {
        particlesCheck += rings[i].density;
        if (particleID <= particlesCheck)
        {
            index = i;
            break;
        }
    }
    return index;
}

int RingRelativeID(int ringID, int particleID)
{
    int relativeID = particleID;
    
    for (int i = 0; i < ringID; i++)
    {
        relativeID -= rings[i].density;
    }
    return relativeID;
}

float CalcRingDistance(int ringID, int particleID)
{
    float distance = 0;
    distance += parentPlanetRadius + startRingDistance;
    
    float ringWidthRow = floor(RingRelativeID(ringID, particleID) / (rings[ringID].density / (rings[ringID].width)));;
    float widthOffset = ringWidthRow * ringWidthOffset;
    distance += widthOffset;
    
    float offset = 0;
    for (int i = 0; i < ringID; i++)
    {
        offset += (rings[i].width + 5) * ringWidthOffset;
    }
    distance += offset;
    
    return distance;
}

float2 World3DToScreen2D(float3 worldPos3D)
{
    float4 posClip = mul(projectionMatrix, float4(worldPos3D, 1)).xyzw;
    posClip /= posClip.w;
    float2 halfCam = camSize * 0.5f;
    return float2((posClip.x * halfCam.x) + halfCam.x, (posClip.y * halfCam.y) + halfCam.y);
}

float Linear01DepthC(float depth)
{
    float near = camNearClipPlane;
    float far = camFarClipPlane;
    return (2.0 * near) / (far + near - depth * (far - near));
}

[numthreads(256, 1, 1)]
void CalcRings(uint3 id : SV_DispatchThreadID)
{
    if (id.x < 0 || id.x >= particleCount)
        return;
    
    int currentID = id.x;
    Particle p = particles[currentID];
      
    if (firstLoop)
    {             
        int ringIndex = GetRingIndex(currentID);
                  
        ringWidthOffset = 0.1f;
        float distance = CalcRingDistance(ringIndex, currentID);
        
        float heightOffset = planets[parentPlanetID].position.y;
        
        float angle = 360.0 / (rings[ringIndex].density / rings[ringIndex].width) * RingRelativeID(ringIndex, currentID);
        angle = angle * (PI / 180);
        
        p.position = float3(cos(angle) * distance + planets[parentPlanetID].position.x, heightOffset, sin(angle) * distance + planets[parentPlanetID].position.z);
                                      
        //calculate initial velocity for perfect orbit based on distance
        float3 forceDirection = planets[parentPlanetID].position - p.position;
        float forceDirectionLength = length(forceDirection);
        float3 unitPerpVector = normalize(float3(forceDirection.z, forceDirection.y, -forceDirection.x));
        float centForce = (gravConstant * planets[parentPlanetID].mass) / sqrt(forceDirectionLength);
                 
        p.velocity = (unitPerpVector * centForce);
        p.color = rings[ringIndex].color;
    }
     
    //calculate newton
       
    float3 forceVector;
    for (int i = 0; i < planetCount; i++)
    {
        float3 forceDirection = planets[i].position - p.position;
        float forceDirectionLength = length(forceDirection);
        float gravityForce = gravConstant * (planets[i].mass * particleMass) / (forceDirectionLength * forceDirectionLength);
        forceVector += normalize(forceDirection) * gravityForce;
            
        //disable particle if collided with planet
    }
          
    //set velocity and position using newton
    p.velocity += forceVector;
    p.position += p.velocity * timeStep;
          
    float2 particleScreenPos = World3DToScreen2D(p.position);
      
    particles[currentID] = p;
          
    float depthValue = Linear01Depth(camDepthTexture[particleScreenPos].r) * camFarClipPlane;
    float posZ = mul(projectionMatrix, float4(p.position, 1)).z;
    

    //Dont render if out planes
    if (posZ > camFarClipPlane || posZ < camNearClipPlane)
    {
        return;
    }
    
    //dont render if obstructed
    if (posZ > depthValue)
    {
        return;
    }
    
    //render
    particlesTexture[particleScreenPos] = float4(p.color, 1);
}

[numthreads(8, 8, 1)]
void ClearFrame(uint3 id : SV_DispatchThreadID)
{
    //clear texture
    particlesTexture[id.xy] = float4(0, 0, 0, 0); 
}
   